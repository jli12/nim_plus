import socketimport sysimport structfrom PyQt5.QtWidgets import *from PyQt5.QtCore import QSize	from ctypes import *import booleanimport reglobal userIPuserIP = Nonech_vals = [-1] * 8# localhost = 127.0.0.1""" This class defines a C-like struct """class Payload(Structure):	_fields_ = [("dacData", c_uint32),				("dacNum", c_uint32),				("deadtime", c_float),				("top", c_uint32),				("middle", c_uint32),				("bottom", c_uint32),				("bool_vars", c_uint32),				("bool_bits", c_uint32)]class MainWindow(QMainWindow):	def __init__(self):		QMainWindow.__init__(self)		WIN_X = 640		WIN_Y = 640		self.setMinimumSize(QSize(WIN_X, WIN_Y))			self.setWindowTitle("Threshold Input") 				## Init some vars		self.threshold = 100.0		self.dacNum = 0		self.dacData = 0		#### ---- DAC # ---- ####		self.cb_lbl = QLabel('Channel to Adjust Threshold:', self)		self.cb = QComboBox(self)		self.cb.addItems(['1', '2', '3', '4', '5', '6', '7', '8'])		self.cb.move(160, 40)		self.cb.resize(60, 32)  # size of input box		self.cb_lbl.move(30, 40)		self.cb_lbl.resize(125, 32)  # size of input box		#### ---- THRESHOLD ---- ####		self.thresh_lbl = QLabel('Threshold value:', self)		self.thresh_box = QLineEdit(self)		self.thresh_box.setText("20")		self.mv_lbl = QLabel('mV', self)		self.thresh_lbl.move(50, 80)		self.thresh_box.move(160, 80)		self.thresh_box.resize(60, 32)  # size of input box		self.mv_lbl.move(225, 80)		#### ---- DEADTIME ---- ####		self.dtime_lbl = QLabel('Deadtime:', self)		self.dtime_in = QLineEdit(self)		self.dtime_in.setText("50")		self.ms_lbl = QLabel('ms', self)		self.dtime_lbl.move(85, 120)		self.dtime_in.move(160, 120)  # location of input box (x,y)		self.dtime_in.resize(60, 32)  # size of input box		self.ms_lbl.move(225, 120)		#### ---- Set top channel ---- ####		self.top_lbl = QLabel('Top Channel:', self)		self.top= QComboBox(self)		self.top.addItems(['1', '2', '3', '4', '5', '6', '7', '8'])		self.top.setCurrentIndex(3)		self.top.move(420, 40) # Input box		self.top.resize(60, 32)  		self.top_lbl.move(320, 40) # Input label		self.top_lbl.resize(125, 32) 		#### ---- Set middle channel ---- ####		self.middle_lbl = QLabel('Middle Channel:', self)		self.middle = QComboBox(self)		self.middle.addItems(['1', '2', '3', '4', '5', '6', '7', '8'])		self.middle.setCurrentIndex(5)		self.middle.move(420, 80)		self.middle.resize(60, 32)  # size of input box		self.middle_lbl.move(320, 80)		self.middle_lbl.resize(125, 32)  # size of input box		#### ---- Set bottom channel ---- ####		self.bottom_lbl = QLabel('Bottom Channel:', self)		self.bottom = QComboBox(self)		self.bottom.addItems(['1', '2', '3', '4', '5', '6', '7', '8'])		self.bottom.setCurrentIndex(4)		self.bottom.move(420, 120)		self.bottom.resize(60, 32)  # size of input box		self.bottom_lbl.move(320, 120)		self.bottom_lbl.resize(125, 32)  # size of input box				#### ---- BOOLEAN INPUT ---- ####		self.bool_lbl = QLabel('Boolean Input (combination of vars and ops:\nVariables = {\'x\',\'y\',\'z\'}\nOperations = {\'&\', \'|\', \'~\', \'(\', \')\'}', self)		self.bool_lbl.move(int(WIN_X/2)-120, int(WIN_Y*4.5/13)-50)		self.bool_lbl.resize(400, 48)		self.bool_box = QLineEdit(self)		# self.bool_box.setText("20")		self.bool_box.move(int(WIN_X/2)-120, int(WIN_Y*4.5/13))		self.bool_box.resize(240, 32)  # size of input box		#### ---- CHANNEL DISPLAYS ---- ####		# self.ch_lbl = QLabel('Channel Values:', self)		self.ch1_lbl = QLabel('Ch 1:', self)		self.ch2_lbl = QLabel('Ch 2:', self)		self.ch3_lbl = QLabel('Ch 3:', self)		self.ch4_lbl = QLabel('Ch 4:', self)		self.ch5_lbl = QLabel('Ch 5:', self)		self.ch6_lbl = QLabel('Ch 6:', self)		self.ch7_lbl = QLabel('Ch 7:', self)		self.ch8_lbl = QLabel('Ch 8:', self)		self.ch1 = QTextBrowser(self)		self.ch2 = QTextBrowser(self)		self.ch3 = QTextBrowser(self)		self.ch4 = QTextBrowser(self)		self.ch5 = QTextBrowser(self)		self.ch6 = QTextBrowser(self)		self.ch7 = QTextBrowser(self)		self.ch8 = QTextBrowser(self)		# split between 17		# Channel 1		ch_window_y = int(WIN_Y*5/11)		self.ch1.move(int(WIN_X*1/17)-10, ch_window_y)		self.ch1.resize(int(WIN_X/17)+10, int(WIN_X/17))		self.ch1.append("null")		self.ch1_lbl.move(int(WIN_X*1/17)-3, ch_window_y-25)		# Channel 2		self.ch2.move(int(WIN_X*3/17)-10, ch_window_y)		self.ch2.resize(int(WIN_X/17)+10, int(WIN_X/17))		self.ch2.append("null")		self.ch2_lbl.move(int(WIN_X*3/17)-3, ch_window_y-25)		# Channel 3		self.ch3.move(int(WIN_X*5/17)-10, ch_window_y)		self.ch3.resize(int(WIN_X/17)+10, int(WIN_X/17))		self.ch3.append("null")		self.ch3_lbl.move(int(WIN_X*5/17)-3, ch_window_y-25)		# Channel 4		self.ch4.move(int(WIN_X*7/17)-10, ch_window_y)		self.ch4.resize(int(WIN_X/17)+10, int(WIN_X/17))		self.ch4.append("null")		self.ch4_lbl.move(int(WIN_X*7/17)-3, ch_window_y-25)		# Channel 5		self.ch5.move(int(WIN_X*9/17)-10, ch_window_y)		self.ch5.resize(int(WIN_X/17)+10, int(WIN_X/17))		self.ch5.append("null")		self.ch5_lbl.move(int(WIN_X*9/17)-3, ch_window_y-25)		# Channel 6		self.ch6.move(int(WIN_X*11/17)-10, ch_window_y)		self.ch6.resize(int(WIN_X/17)+10, int(WIN_X/17))		self.ch6.append("null")		self.ch6_lbl.move(int(WIN_X*11/17)-3, ch_window_y-25)		# Channel 7		self.ch7.move(int(WIN_X*13/17)-10, ch_window_y)		self.ch7.resize(int(WIN_X/17)+10, int(WIN_X/17))		self.ch7.append("null")		self.ch7_lbl.move(int(WIN_X*13/17)-3, ch_window_y-25)		# Channel 8		self.ch8.move(int(WIN_X*15/17)-10, ch_window_y)		self.ch8.resize(int(WIN_X/17)+10, int(WIN_X/17))		self.ch8.append("null")		self.ch8_lbl.move(int(WIN_X*15/17)-3, ch_window_y-25)		#### ---- OUTPUT REDIRECTION BOX ---- ####		self.output_lbl = QLabel('Output for user:', self)		self.output_rd = QTextBrowser(self)		self.output_rd.move(int(WIN_X/9), int(2*WIN_Y/3))		self.output_rd.resize(int(WIN_X*7/9), int(WIN_Y/3)-10)		# self.output_rd.append("hi")		self.output_lbl.move(int(WIN_X/9), int(2*WIN_Y/3)-25)		# self.output_lbl.resize(125, 32)  # size of input box		#### ---- Submit button ---- ####		pybutton = QPushButton('Set Configuration', self)		pybutton.clicked.connect(self.on_button_clicked)		pybutton.move(int(WIN_X/2-100), int(2*WIN_Y/3)-70)		pybutton.resize(200,32)	# Once "set configuration" button has been clicked	def on_button_clicked(self):        # convert to volts		self.threshold = float(self.thresh_box.text())/1000 		self.dacNum = self.cb.currentIndex() + 1        # convert to multiples of 10ns		self.deadtime = int(float(self.dtime_in.text())*10**5)		if self.threshold < 0.02:			self.display_msg("ERROR: Input threshold below 20mV bound. Value overridden and set to 20mV.\n")			self.threshold = 0.02		elif self.threshold > 0.2:			self.display_msg("ERROR: Input threshold above 200mV bound. Value overridden and set to 200mV.\n")			self.threshold = 0.2		# print("DAC ", self.dacNum, " threshold set to: ", float(self.threshold), "V")		#Convert threshold into DAC databits		# Assumes threshold is put as positive for negative pulse heights		DAC = 1.4-5*self.threshold 		self.dacData = int(4096*DAC/3.3) # Convert into the 12-bit number for DAC		self.dacData += (self.dacNum-1)*2**12		# dacData is at most 4096, reserving 4 digits is safe        		## Handle boolean		self.bool_str = self.bool_box.text()		self.bool_str = self.bool_str.replace(" ", "")		bool_err = self.parse_boolean()		if (bool_err == -1):			self.display_msg("ERROR: Invalid variable included.\n")			return;		elif (bool_err == -2): 			self.display_msg("ERROR: Invalid boolean function. Please enter a valid function.\n")			return;		elif (bool_err == 0): 			self.display_msg("NOTE: No boolean function inputed.\n")			return;		self.send_bitstream()		self.update_text(self.dacNum, self.threshold)		self.display_msg("DAC "+str(self.dacNum)+" threshold set to: "+str(float(self.threshold))+\			"V with a deadtime of "+f'{self.deadtime/10**5:,}'+"ms")		self.display_msg("Boolean Function: " + self.bool_str + "\n")		# self.display_msg(self.vars_present + "    " + str(self.bool_bits))		alert = QMessageBox()		alert.setText('Input received')		alert.exec()	# send the bytestreamt to a port	def send_bitstream(self):		s = socket.socket()		# HOST, PORT = "localhost", 22		# HOST = socket.gethostname("") # essentially "localhost"		HOST = socket.gethostbyname('localhost')		if userIP != None:			HOST = userIP		PORT = 8888		# Create a socket (SOCK_STREAM means a TCP socket)		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)		# Connect to server and send data		s.connect((HOST, PORT))		# s.sendall(ba)		# print(self.bool_bits) 		payload_out = Payload(self.dacData, self.dacNum, self.deadtime, 			self.top.currentIndex()+1, self.middle.currentIndex()+1, self.bottom.currentIndex()+1,			self.bool_vars, self.bool_bits)		# print("Sending dacData=%d, dacNum=%d, deadtime=%i, top=%d, middle=%d, bottom=%d" % \		# 	(self.dacData, self.dacNum, self.deadtime, self.top.currentIndex()+1, self.middle.currentIndex()+1, self.bottom.currentIndex()+1))		nsent = s.send(payload_out)	def parse_boolean(self):		invalid_var = ['xy', 'yx', 'xz', 'zx', 'yz', 'zy', 'xyz', 'yxz', 'xzy', 'zxy', 'yzx', 'zyx'] # if inputed, throw an error				# check input variables for invalid variables		if (re.search('[a-wA-W]', self.bool_str) != None):			return -1; 		elif (any(var in self.bool_str for var in invalid_var)):			return -1;		# init vars to pass to server		bool_vars = 0 # xyz (e.g. 010 if only y)		vars_present = "" # string of present vars		bool_bits = "" # string of bits corresponding to truth table		# determine the present variables		if ('x' in self.bool_str): bool_vars += 100; vars_present += 'x'; 		if ('y' in self.bool_str): bool_vars += 10; vars_present += 'y'; 		if ('z' in self.bool_str): bool_vars += 1; vars_present += 'z'; 		# print(vars_present)		algebra = boolean.BooleanAlgebra()		# x,y,z = algebra.symbols('x','y','z')		# determine if boolean function is valid or not		if (len(self.bool_str) > 1):			# print(algebra.parse(self.bool_str))			try:				self.bool_str = algebra.parse(self.bool_str)			except: 				return -2; # invalid bool function		# just one variable as the whole function		elif (len(self.bool_str) == 1):			self.bool_vars = bool_vars			self.bool_bits = 10			return 1;		# function is left empty		elif (len(self.bool_str) == 0):			self.bool_vars = 0			self.vars_present = ""			self.bool_bits = 0			return 0;		# replace logical ops for python to evaluate		self.bool_str = str(self.bool_str).replace('&', ' and ').replace('|', ' or ').replace('~', ' not ')		# create truth table bits		if ('x' in vars_present):			if ('y' in vars_present):				if ('z' in vars_present): # x, y, and z					bool_bits += str(int(eval(self.bool_str.replace('x', 'True').replace('y', 'True').replace('z', 'True')))) # 1 1 1					bool_bits += str(int(eval(self.bool_str.replace('x', 'True').replace('y', 'True').replace('z', 'False'))))  # 1 1 0					bool_bits += str(int(eval(self.bool_str.replace('x', 'True').replace('y', 'False').replace('z', 'True')))) # 1 0 1					bool_bits += str(int(eval(self.bool_str.replace('x', 'True').replace('y', 'False').replace('z', 'False')))) # 1 0 0 					bool_bits += str(int(eval(self.bool_str.replace('x', 'False').replace('y', 'True').replace('z', 'True')))) # 0 1 1					bool_bits += str(int(eval(self.bool_str.replace('x', 'False').replace('y', 'True').replace('z', 'False')))) # 0 1 0					bool_bits += str(int(eval(self.bool_str.replace('x', 'False').replace('y', 'False').replace('z', 'True')))) # 0 0 1					bool_bits += str(int(eval(self.bool_str.replace('x', 'False').replace('y', 'False').replace('z', 'False')))) # 0 0 0				else: # just x and y					bool_bits += str(int(eval(self.bool_str.replace('x', 'True').replace('y', 'True')))) # 1 1					bool_bits += str(int(eval(self.bool_str.replace('x', 'True').replace('y', 'False')))) # 1 0					bool_bits += str(int(eval(self.bool_str.replace('x', 'False').replace('y', 'True')))) # 0 1					bool_bits += str(int(eval(self.bool_str.replace('x', 'False').replace('y', 'False')))) # 0 0			else: 				if ('z' in vars_present): # x and z					bool_bits += str(int(eval(self.bool_str.replace('x', 'True').replace('z', 'True')))) # 1 1					bool_bits += str(int(eval(self.bool_str.replace('x', 'True').replace('z', 'False')))) # 1 0					bool_bits += str(int(eval(self.bool_str.replace('x', 'False').replace('z', 'True')))) # 0 1					bool_bits += str(int(eval(self.bool_str.replace('x', 'False').replace('z', 'False')))) # 0 0				else: # just x					bool_bits += str(int(eval(self.bool_str.replace('x', 'True')))) # 1					bool_bits += str(int(eval(self.bool_str.replace('x', 'False')))) # 0		elif ('y' in vars_present):			if('z' in vars_present): # just y and z				bool_bits += str(int(eval(self.bool_str.replace('y', 'True').replace('z', 'True')))) # 1 1				bool_bits += str(int(eval(self.bool_str.replace('y', 'True').replace('z', 'False')))) # 1 0				bool_bits += str(int(eval(self.bool_str.replace('y', 'False').replace('z', 'True')))) # 0 1				bool_bits += str(int(eval(self.bool_str.replace('y', 'False').replace('z', 'False')))) # 0 0			else: # just y				bool_bits += str(int(eval(self.bool_str.replace('y', 'True')))) # 1				bool_bits += str(int(eval(self.bool_str.replace('y', 'False')))) # 0		else: # just z			bool_bits += str(int(eval(self.bool_str.replace('z', 'True')))) # 1			bool_bits += str(int(eval(self.bool_str.replace('z', 'False')))) # 0		self.bool_vars = bool_vars		self.vars_present = vars_present		self.bool_bits = int(bool_bits)		return 1;	def update_text(self, chNum, text):		if chNum == 1:			self.ch1.clear()			self.ch1.append(str(text))		elif chNum == 2:			self.ch2.clear()			self.ch2.append(str(text))		elif chNum == 3:			self.ch3.clear()			self.ch3.append(str(text))		elif chNum == 4:			self.ch4.clear()			self.ch4.append(str(text))		elif chNum == 5:			self.ch5.clear()			self.ch5.append(str(text))		elif chNum == 6:			self.ch6.clear()			self.ch6.append(str(text))		elif chNum == 7:			self.ch7.clear()			self.ch7.append(str(text))		else:			self.ch8.clear()			self.ch8.append(str(text))	def display_msg(self, error):		self.output_rd.append(str(error))if __name__ == '__main__':	ipARG = 1	try:		userIP = sys.argv[1];	except IndexError:		ipARG = 0		# print("No host IP specified. Default set to localhost.")	app = QApplication(sys.argv)	mainWin = MainWindow()	mainWin.show()	if not ipARG:		mainWin.display_msg("NOTE: No host IP specified. Default set to localhost.\n")	# mainWin.display_msg("test")	sys.exit(app.exec_())	